const AnalyticsRepository = require('../repositories/analyticsRepository');
const CourseRepository = require('../repositories/courseRepository');

class AnalyticsService {
    constructor() {
        this.analyticsRepo = new AnalyticsRepository();
        this.courseRepo = new CourseRepository();
    }

    // Registrar b√∫squeda con an√°lisis de intenci√≥n
    async recordSearchWithIntent(query, results, intent = null) {
        await this.analyticsRepo.recordSearch(query, results.length);
        
        // Si no se proporciona intenci√≥n, intentar inferirla
        if (!intent) {
            intent = this.inferIntentFromQuery(query);
        }
        
        console.log(`üìä Analytics: B√∫squeda "${query}" ‚Üí ${intent} (${results.length} resultados)`);
    }

    // Inferir intenci√≥n de la consulta
    inferIntentFromQuery(query) {
        query = query.toLowerCase();
        
        if (query.includes('hora') || query.includes('horario') || query.includes('cu√°ndo')) {
            return 'consulta_horario';
        } else if (query.includes('material') || query.includes('ejercicio') || query.includes('tarea')) {
            return 'solicitar_material';
        } else if (query.includes('qu√© es') || query.includes('que es') || query.includes('explicame') || query.includes('c√≥mo funciona')) {
            return 'duda_teorica';
        } else if (query.includes('examen') || query.includes('parcial') || query.includes('califica')) {
            return 'consulta_evaluacion';
        } else {
            return 'consulta_general';
        }
    }

    // PREDICCI√ìN DE CURSO M√ÅS BUSCADO
    async predictPopularCourse() {
        const trends = await this.analyticsRepo.getSearchTrends(20);
        const courses = await this.courseRepo.findAll();
        
        if (trends.length === 0) {
            return {
                predictedCourse: 'Programaci√≥n I', // Default
                confidence: 0.5,
                reason: 'Sin datos suficientes, curso por defecto',
                searchCount: 0
            };
        }

        // An√°lisis de correlaci√≥n entre b√∫squedas y cursos
        const courseScores = {};
        
        for (const trend of trends) {
            const foundCourses = await this.courseRepo.search(trend.query);
            foundCourses.forEach(course => {
                courseScores[course.nombre] = (courseScores[course.nombre] || 0) + trend.count;
            });
        }

        // Encontrar curso con mayor score
        let topCourse = { nombre: '', score: 0 };
        Object.entries(courseScores).forEach(([nombre, score]) => {
            if (score > topCourse.score) {
                topCourse = { nombre, score };
            }
        });

        const confidence = Math.min(topCourse.score / 50, 0.95); // M√°ximo 95% de confianza

        return {
            predictedCourse: topCourse.nombre || 'Programaci√≥n I',
            confidence: confidence,
            searchCount: topCourse.score,
            reason: `Basado en ${topCourse.score} b√∫squedas relacionadas este mes`,
            trendingQueries: trends.slice(0, 5)
        };
    }

    // Obtener analytics completos
    async getCompleteAnalytics() {
        const [searchTrends, chatAnalytics, popularCourse] = await Promise.all([
            this.analyticsRepo.getSearchTrends(10),
            this.analyticsRepo.getChatAnalytics(),
            this.predictPopularCourse()
        ]);

        return {
            searchTrends,
            chatAnalytics,
            popularCourse,
            timestamp: new Date().toISOString()
        };
    }

    // Registrar conversaci√≥n del chatbot
    async recordChatInteraction(userMessage, botResponse, intent, confidence) {
        return await this.analyticsRepo.recordChatMessage(
            userMessage, 
            botResponse, 
            intent, 
            confidence
        );
    }

    // Registrar feedback del usuario
    async recordUserFeedback(conversationId, rating, comments) {
        return await this.analyticsRepo.recordFeedback(conversationId, rating, comments);
    }
}

module.exports = AnalyticsService;